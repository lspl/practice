## 最小路径和

**Problem**：给定一个二维数组，二维数组中的每个数都是正数，要求从左上角走到右下角，每一步只能向右或者向下。沿途经过的数字要累加起来。返回最小的路径和。

**Analysis**：可能你已经想到这个题适合用动态规划来解。但是，由于动态规划的本质是“记忆型递归”。对于不熟悉动态规划的人来说，非常有必要从递归开始理解求解过程。一旦用递归解决了这个问题，逆向求解，就可以得到动态规划的思路。

&ensp;&ensp;&ensp;&ensp;对于矩阵中的任意一个位置{i,j}，如果它处于矩阵的第一行或第一列上，则从起点到它的距离distance一定为从[0,0]直接到它的距离的和。如果不处于矩阵的第一行，也不出一第一列，则distance的值为从起点到它的左上角{i-1,j-1}的距离加上{matrix[i-1]\[j], matrix[i]\[j-1]}两者的最小值加上matrix[i]\[j]的和，也就是从它的左上角处选择向右还是向下。


```java
/**
 * @author lishunpu
 * @create 2017-12-27 10:30
 */
public class MinPathSum {
    public static void main(String[] args) {
        int[][] matrix = {
                {9, 5, 3, 7, 8},
                {7, 2, 9, 1, 4},
                {3, 5, 12, 5, 6},
                {2, 10, 11, 1, 3},
        };
        System.out.println(minPathSum(matrix));
    }

    private static int minPathSum(int[][] matrix) {
        return minSum(matrix, matrix.length - 1, matrix[0].length - 1);
    }

    private static int minSum(int[][] matrix, int i, int j) {
        if (i == 0 && j == 0) {
            return matrix[i][j];
        }
        if (i == 0) {
            return matrix[i][j] + minSum(matrix, i, j - 1);
        }
        if (j == 0) {
            return matrix[i][j] + minSum(matrix, i - 1, j);
        }
        return matrix[i][j] + Math.min(minSum(matrix, i - 1, j), minSum(matrix, i, j - 1));
    }
}
```